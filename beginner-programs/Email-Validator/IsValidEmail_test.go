// ********RoostGPT********
/*
Test generated by RoostGPT for test gotest1 using AI Type  and AI Model 

ROOST_METHOD_HASH=IsValidEmail_9ebd397bff
ROOST_METHOD_SIG_HASH=IsValidEmail_d2603fb18f

Scenario 1: Test with a valid email
Details: 
    Description: The test is meant to check whether the function correctly validates a properly formatted email.
Execution: 
    Arrange: Create a string variable with a valid email address.
    Act: Invoke the IsValidEmail function with the valid email.
    Assert: The function should return true.
Validation: 
    The choice of assertion is to verify that the function correctly validates a properly formatted email. The logic behind the expected result is that the email is correctly formatted and is not longer than 255 characters. This test is important to ensure that the function correctly identifies valid emails.

Scenario 2: Test with an invalid email
Details: 
    Description: The test is meant to check whether the function correctly identifies an invalid email.
Execution: 
    Arrange: Create a string variable with an invalid email address.
    Act: Invoke the IsValidEmail function with the invalid email.
    Assert: The function should return false.
Validation: 
    The choice of assertion is to verify that the function correctly identifies an invalid email. The logic behind the expected result is that the email is incorrectly formatted. This test is important to ensure that the function correctly identifies invalid emails.

Scenario 3: Test with a valid, but overly long email
Details: 
    Description: The test is meant to check whether the function correctly identifies a valid but overly long email.
Execution: 
    Arrange: Create a string variable with a valid but overly long email address (greater than 255 characters).
    Act: Invoke the IsValidEmail function with the overly long email.
    Assert: The function should return false.
Validation: 
    The choice of assertion is to verify that the function correctly identifies a valid but overly long email. The logic behind the expected result is that the email is correctly formatted but is longer than 255 characters. This test is important to ensure that the function correctly identifies overly long emails.

Scenario 4: Test with an empty string
Details: 
    Description: The test is meant to check whether the function correctly identifies an empty string as an invalid email.
Execution: 
    Arrange: Create a string variable with an empty string.
    Act: Invoke the IsValidEmail function with the empty string.
    Assert: The function should return false.
Validation: 
    The choice of assertion is to verify that the function correctly identifies an empty string as an invalid email. The logic behind the expected result is that an empty string is not a valid email address. This test is important to ensure that the function correctly identifies empty strings as invalid emails.
*/

// ********RoostGPT********
package Validator

import (
	"regexp"
	"testing"
)

func TestIsValidEmail(t *testing.T) {
	// define valid email regex
	emailRegexp := regexp.MustCompile(`^[\w-]+(\.[\w-]+)*@([\w-]+\.)+[a-zA-Z]{2,7}$`)

	// table driven tests
	tests := []struct {
		name     string
		email    string
		expected bool
	}{
		{
			name:     "Valid email",
			email:    "testEmail@example.com",
			expected: true,
		},
		{
			name:     "Invalid email",
			email:    "testEmail@.com",
			expected: false,
		},
		{
			name:     "Overly long email",
			email:    "longemail" + string(make([]byte, 256)) + "@example.com",
			expected: false,
		},
		{
			name:     "Empty string",
			email:    "",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := IsValidEmail(tt.email, emailRegexp); got != tt.expected {
				t.Errorf("IsValidEmail() = %v, expected %v", got, tt.expected)
			}
		})
	}
}

func IsValidEmail(email string, emailRegexp *regexp.Regexp) bool {
	if len(email) > 255 {
		return false
	}
	return emailRegexp.MatchString(email)
}
