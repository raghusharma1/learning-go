// ********RoostGPT********
/*
Test generated by RoostGPT for test gotest1 using AI Type  and AI Model 

ROOST_METHOD_HASH=IsValidEmail_9ebd397bff
ROOST_METHOD_SIG_HASH=IsValidEmail_d2603fb18f

Scenario 1: Test with a valid email
Details: 
    Description: The test is meant to check whether the function correctly validates a properly formatted email.
Execution: 
    Arrange: Create a string variable with a valid email address.
    Act: Invoke the IsValidEmail function with the valid email.
    Assert: The function should return true.
Validation: 
    The choice of assertion is to verify that the function correctly validates a properly formatted email. The function should return true, if it doesn't then there's a problem with the function's validation logic. This test is important to ensure that the function can correctly validate normal, properly formatted emails.

Scenario 2: Test with an invalid email
Details: 
    Description: The test is meant to check whether the function correctly identifies an improperly formatted email.
Execution: 
    Arrange: Create a string variable with an invalid email address.
    Act: Invoke the IsValidEmail function with the invalid email.
    Assert: The function should return false.
Validation: 
    The choice of assertion is to verify that the function correctly identifies an improperly formatted email. The function should return false, if it doesn't then there's a problem with the function's validation logic. This test is important to ensure that the function can correctly identify and reject invalid emails.

Scenario 3: Test with an email that is too long
Details: 
    Description: The test is meant to check whether the function correctly identifies an email that is too long.
Execution: 
    Arrange: Create a string variable with an email that is more than 255 characters long.
    Act: Invoke the IsValidEmail function with the long email.
    Assert: The function should return false.
Validation: 
    The choice of assertion is to verify that the function correctly identifies an email that is too long. The function should return false, if it doesn't then there's a problem with the function's validation logic. This test is important to ensure that the function can correctly identify and reject emails that are too long.

Scenario 4: Test with an empty email
Details: 
    Description: The test is meant to check whether the function correctly identifies an empty string.
Execution: 
    Arrange: Create a string variable with an empty string.
    Act: Invoke the IsValidEmail function with the empty string.
    Assert: The function should return false.
Validation: 
    The choice of assertion is to verify that the function correctly identifies an empty string. The function should return false, if it doesn't then there's a problem with the function's validation logic. This test is important to ensure that the function can correctly identify and reject empty strings as they are not valid emails.
*/

// ********RoostGPT********
package Validator

import (
	"regexp"
	"testing"
)

var emailRegexp = regexp.MustCompile("^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")

func TestIsValidEmail(t *testing.T) {
	tests := []struct {
		name  string
		email string
		want  bool
	}{
		{
			name:  "Test with a valid email",
			email: "test@example.com",
			want:  true,
		},
		{
			name:  "Test with an invalid email",
			email: "invalid.email",
			want:  false,
		},
		{
			name:  "Test with an email that is too long",
			email: "this.email.is.way.too.long.to.be.valid.and.should.return.false.as.it.exceeds.the.maximum.length.that.a.valid.email.can.be.this.email.is.way.too.long.to.be.valid.and.should.return.false.as.it.exceeds.the.maximum.length.that.a.valid.email.can.be@toolong.com",
			want:  false,
		},
		{
			name:  "Test with an empty email",
			email: "",
			want:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := IsValidEmail(tt.email); got != tt.want {
				t.Errorf("IsValidEmail() = %v, want %v", got, tt.want)
			}
		})
	}
}
