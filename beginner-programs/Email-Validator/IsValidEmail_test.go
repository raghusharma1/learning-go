// ********RoostGPT********
/*
Test generated by RoostGPT for test gotest1 using AI Type  and AI Model 

ROOST_METHOD_HASH=IsValidEmail_9ebd397bff
ROOST_METHOD_SIG_HASH=IsValidEmail_d2603fb18f

Scenario 1: Test with a valid email
Details: 
    Description: The test is meant to check whether the function correctly validates a properly formatted email.
Execution: 
    Arrange: Create a string variable with a valid email address.
    Act: Invoke the IsValidEmail function with the valid email.
    Assert: The function should return true.
Validation: 
    The choice of assertion is to verify that the function correctly validates a properly formatted email. The function should return true, if it doesn't then there's a problem with the function's validation logic. This test is important to ensure that the function can correctly validate normal, valid emails.

Scenario 2: Test with an invalid email
Details: 
    Description: The test is meant to check whether the function correctly identifies an improperly formatted email.
Execution: 
    Arrange: Create a string variable with an invalid email address.
    Act: Invoke the IsValidEmail function with the invalid email.
    Assert: The function should return false.
Validation: 
    The choice of assertion is to verify that the function correctly identifies an improperly formatted email. The function should return false, if it doesn't then there's a problem with the function's validation logic. This test is important to ensure that the function can correctly identify invalid emails.

Scenario 3: Test with an empty string
Details: 
    Description: The test is meant to check whether the function correctly identifies an empty string as an invalid email.
Execution: 
    Arrange: Create a string variable with an empty string.
    Act: Invoke the IsValidEmail function with the empty string.
    Assert: The function should return false.
Validation: 
    The choice of assertion is to verify that the function correctly identifies an empty string as an invalid email. The function should return false, if it doesn't then there's a problem with the function's validation logic. This test is important to ensure that the function can correctly handle edge cases like an empty string.

Scenario 4: Test with a very long email
Details: 
    Description: The test is meant to check whether the function correctly identifies an email that exceeds the maximum length as invalid.
Execution: 
    Arrange: Create a string variable with an email address that exceeds the maximum length of 255 characters.
    Act: Invoke the IsValidEmail function with the long email.
    Assert: The function should return false.
Validation: 
    The choice of assertion is to verify that the function correctly identifies an overly long email as invalid. The function should return false, if it doesn't then there's a problem with the function's validation logic. This test is important to ensure that the function can correctly handle edge cases like overly long emails.
*/

// ********RoostGPT********
package Validator

import (
	"testing"
)

func TestIsValidEmail(t *testing.T) {
	var tests = []struct {
		input string
		want  bool
	}{
		{"test@example.com", true},
		{"test.example.com", false},
		{"", false},
		{"a" + strings.Repeat("@example.com", 30), false},
	}

	for _, tt := range tests {
		testname := tt.input
		t.Run(testname, func(t *testing.T) {
			ans := IsValidEmail(tt.input)
			if ans != tt.want {
				t.Errorf("got %t, want %t", ans, tt.want)
			}
		})
	}
}
