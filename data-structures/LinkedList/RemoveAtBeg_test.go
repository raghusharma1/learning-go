// ********RoostGPT********
/*
Test generated by RoostGPT for test goastparsertest using AI Type  and AI Model 

ROOST_METHOD_HASH=RemoveAtBeg_2301eda597
ROOST_METHOD_SIG_HASH=RemoveAtBeg_e45f33f4b9

Here are several test scenarios for the `RemoveAtBeg` function, covering normal operation, edge cases, and error handling, while following the format you specified:

---

### Scenario 1: Remove from an Empty LinkedList

**Details:**
- **Description:** This test checks the behavior of the `RemoveAtBeg` function when called on an empty linked list. The function should return `-1` when there are no elements to remove.
  
**Execution:**
- **Arrange:** Create an empty linked list (`ll.head = nil`).
- **Act:** Call the `RemoveAtBeg` function.
- **Assert:** Verify that the function returns `-1`.

**Validation:**
- The expected result is `-1` because the linked list is empty, and there are no elements to remove.
- This test ensures that the function handles the edge case of an empty list correctly, preventing potential runtime errors like dereferencing `nil`.

---

### Scenario 2: Remove Single Element from LinkedList

**Details:**
- **Description:** This test checks the behavior when removing the only element in the linked list. After removal, the list should be empty, and the function should return the value of the removed node.
  
**Execution:**
- **Arrange:** Create a linked list with one node (`ll.head = node{val: 10, next: nil, prev: nil}`).
- **Act:** Call the `RemoveAtBeg` function.
- **Assert:** Verify that the function returns `10` (the value of the removed node) and that `ll.head` is `nil` after the removal.

**Validation:**
- The expected result is `10`, and `ll.head` should be `nil` because the only node was removed.
- This test ensures the function works correctly when dealing with a list with a single node, leaving the list empty afterward.

---

### Scenario 3: Remove Multiple Elements Sequentially

**Details:**
- **Description:** This test checks the behavior when removing multiple elements from a linked list sequentially. It ensures that the function correctly updates the head and removes the nodes one by one.
  
**Execution:**
- **Arrange:** Create a linked list with multiple nodes (`ll.head = node{val: 10, next: node{val: 20, next: node{val: 30, next: nil}}}`).
- **Act:** Call the `RemoveAtBeg` function three times.
- **Assert:** Verify that the first call returns `10`, the second call returns `20`, and the third call returns `30`. Also, verify that `ll.head` is `nil` after the third removal.

**Validation:**
- The expected results are `10`, `20`, and `30` for each successive call. After the third removal, the list should be empty (`ll.head = nil`).
- This test ensures the function works correctly when removing elements from a list with more than one node and that the list's state is properly updated each time.

---

### Scenario 4: Remove with Two Nodes in LinkedList

**Details:**
- **Description:** This test checks the behavior when removing the first element from a linked list with two nodes. The second node should become the new head, and its `prev` pointer should be `nil`.
  
**Execution:**
- **Arrange:** Create a linked list with two nodes (`ll.head = node{val: 10, next: node{val: 20, prev: ll.head}}`).
- **Act:** Call the `RemoveAtBeg` function.
- **Assert:** Verify that the function returns `10` and that `ll.head` now points to the second node with value `20`, and its `prev` pointer is `nil`.

**Validation:**
- The expected result is `10`, and after removal, the new head should be the node with value `20`, with its `prev` pointer set to `nil`.
- This test ensures that the function correctly handles lists with two nodes, especially updating the `prev` pointer of the new head node.

---

### Scenario 5: Remove from a Circular LinkedList (Edge Case)

**Details:**
- **Description:** This test checks the behavior of the function when dealing with a circular linked list where the last node points back to the first node. It ensures the function only modifies the `head` and does not affect the circular structure.
  
**Execution:**
- **Arrange:** Create a circular linked list where the last node points to the first node (`ll.head = node{val: 10, next: node{val: 20, next: ll.head}}`).
- **Act:** Call the `RemoveAtBeg` function.
- **Assert:** Verify that the function returns `10`, and that `ll.head` now points to the second node with value `20`, while the circular structure is unaffected.

**Validation:**
- The expected result is `10`, and after removal, the new head should be the node with value `20`. The circular structure should remain intact.
- This test ensures that the function correctly handles edge cases involving circular linked lists, modifying only the head and not the entire structure.

---

### Scenario 6: Remove from a LinkedList with a Single Node and Verify Memory is Freed (Advanced)

**Details:**
- **Description:** This advanced test checks whether the memory is properly freed after removing the only node from the list. This is especially important in environments where memory management is critical.
  
**Execution:**
- **Arrange:** Create a linked list with one node (`ll.head = node{val: 10, next: nil, prev: nil}`).
- **Act:** Call the `RemoveAtBeg` function.
- **Assert:** Verify that the function returns `10` and that `ll.head` is `nil`. Additionally, use tools like Go's garbage collector (or external memory profiling tools) to ensure that the memory for the removed node is freed.

**Validation:**
- The expected result is `10`, and `ll.head` should be `nil`. Memory profiling tools should not show any residual memory usage for the removed node.
- This test ensures that the function doesn't cause memory leaks, which is important for long-running applications where memory usage must be optimized.

---

### Scenario 7: Remove from a LinkedList with Duplicate Values

**Details:**
- **Description:** This test checks the behavior when removing nodes with duplicate values. It ensures that the function removes the correct node (the head) and doesn't remove nodes with the same value later in the list.
  
**Execution:**
- **Arrange:** Create a linked list with duplicate values (`ll.head = node{val: 10, next: node{val: 10, next: node{val: 20}}}`).
- **Act:** Call the `RemoveAtBeg` function.
- **Assert:** Verify that the function returns `10`, and that `ll.head` now points to the second node (with value `10`), which is distinct from the removed node.

**Validation:**
- The expected result is `10`, and after removal, the new head should be the second node with the same value (`10`).
- This test ensures that the function only removes the head node and doesn't mistakenly remove other nodes with the same value.

---

### Scenario 8: Remove from a LinkedList with Complex Node Structure

**Details:**
- **Description:** This test checks the behavior when removing from a list where nodes have complex structures, such as custom objects or additional metadata. It ensures that the function focuses only on updating the head and doesn't interfere with the node's internal structure.
  
**Execution:**
- **Arrange:** Create a linked list where nodes contain additional fields (`ll.head = node{val: 10, next: node{val: 20, metadata: "extra data"}}`).
- **Act:** Call the `RemoveAtBeg` function.
- **Assert:** Verify that the function returns `10`, and that `ll.head` now points to the second node, including preserving its metadata.

**Validation:**
- The expected result is `10`, and after removal, the new head should point to the second node with its metadata intact.
- This test ensures that the function handles nodes with complex structures without causing data corruption.

---

These test scenarios cover various aspects of the `RemoveAtBeg` function, including normal operation, edge cases, and advanced memory management concerns. Each scenario is designed to test a specific aspect of the function's behavior, ensuring that it behaves correctly in different situations.
*/

// ********RoostGPT********
package LinkedList

import (
	"bytes"
	"fmt"
	"testing"
)

type node struct {
	val  int
	next *node
	prev *node
}

type LinkedList struct {
	head *node
}

func (ll *LinkedList) RemoveAtBeg() int {
	if ll.head == nil {
		return -1
	}
	cur := ll.head
	ll.head = cur.next
	if ll.head != nil {
		ll.head.prev = nil
	}
	return cur.val
}

func TestRemoveAtBeg(t *testing.T) {
	tests := []struct {
		name           string
		setup          func() *LinkedList
		expectedReturn int
		expectedHead   *node
	}{
		{
			name: "Remove from an Empty LinkedList",
			setup: func() *LinkedList {
				return &LinkedList{head: nil}
			},
			expectedReturn: -1,
			expectedHead:   nil,
		},
		{
			name: "Remove Single Element from LinkedList",
			setup: func() *LinkedList {
				return &LinkedList{head: &node{val: 10, next: nil, prev: nil}}
			},
			expectedReturn: 10,
			expectedHead:   nil,
		},
		{
			name: "Remove Multiple Elements Sequentially",
			setup: func() *LinkedList {
				n3 := &node{val: 30, next: nil}
				n2 := &node{val: 20, next: n3, prev: nil}
				n1 := &node{val: 10, next: n2, prev: nil}
				n2.prev = n1
				n3.prev = n2
				return &LinkedList{head: n1}
			},
			expectedReturn: 10,
			expectedHead:   &node{val: 20, next: &node{val: 30, next: nil, prev: &node{val: 20, next: nil, prev: nil}}, prev: nil},
		},
		{
			name: "Remove with Two Nodes in LinkedList",
			setup: func() *LinkedList {
				n2 := &node{val: 20, next: nil, prev: nil}
				n1 := &node{val: 10, next: n2, prev: nil}
				n2.prev = n1
				return &LinkedList{head: n1}
			},
			expectedReturn: 10,
			expectedHead:   &node{val: 20, next: nil, prev: nil},
		},
		{
			name: "Remove from a Circular LinkedList (Edge Case)",
			setup: func() *LinkedList {
				n2 := &node{val: 20, next: nil}
				n1 := &node{val: 10, next: n2, prev: nil}
				n2.next = n1 // Circular
				return &LinkedList{head: n1}
			},
			expectedReturn: 10,
			expectedHead:   &node{val: 20, next: &node{val: 10, next: nil, prev: nil}, prev: nil},
		},
		{
			name: "Remove from a LinkedList with Duplicate Values",
			setup: func() *LinkedList {
				n3 := &node{val: 20, next: nil}
				n2 := &node{val: 10, next: n3, prev: nil}
				n1 := &node{val: 10, next: n2, prev: nil}
				n2.prev = n1
				n3.prev = n2
				return &LinkedList{head: n1}
			},
			expectedReturn: 10,
			expectedHead:   &node{val: 10, next: &node{val: 20, next: nil, prev: &node{val: 10, next: nil, prev: nil}}, prev: nil},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ll := tt.setup()

			// Capture the output using a buffer
			var buf bytes.Buffer

			// Simulate the removal
			removedVal := ll.RemoveAtBeg()

			// Write the result to the buffer
			fmt.Fprintf(&buf, "Removed value: %d\n", removedVal)

			// Validate the result
			if removedVal != tt.expectedReturn {
				t.Errorf("RemoveAtBeg() = %d; want %d", removedVal, tt.expectedReturn)
			}

			// Validate the new head state
			if ll.head == nil && tt.expectedHead != nil {
				t.Errorf("Expected head node is not nil, but got nil")
			} else if ll.head != nil && tt.expectedHead == nil {
				t.Errorf("Expected head node is nil, but got non-nil")
			} else if ll.head != nil && ll.head.val != tt.expectedHead.val {
				t.Errorf("Expected head value = %d; got %d", tt.expectedHead.val, ll.head.val)
			}

			t.Log(buf.String()) // Log the output for debugging purposes
		})
	}
}
