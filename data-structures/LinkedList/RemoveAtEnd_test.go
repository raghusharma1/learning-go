// ********RoostGPT********
/*
Test generated by RoostGPT for test goastparsertest using AI Type  and AI Model 

ROOST_METHOD_HASH=RemoveAtEnd_cbcd36b1fc
ROOST_METHOD_SIG_HASH=RemoveAtEnd_5992bd4f5a

### Scenario 1: Removing from an Empty Linked List

Details:
- **Description**: This test checks the behavior of the `RemoveAtEnd` method when the linked list is empty. The function is expected to return `-1` when called on an empty list.
- **Execution**:
  - **Arrange**: Create an empty `LinkedList` object (i.e., `ll.head` is `nil`).
  - **Act**: Call the `RemoveAtEnd` method on the empty list.
  - **Assert**: Verify that the return value is `-1`.
- **Validation**:
  - **Assertion**: The test expects `-1` as the return value, which is explicitly handled in the function when `ll.head == nil`.
  - **Importance**: This test ensures that the function handles empty lists gracefully, which is a common edge case in linked list operations.

---

### Scenario 2: Removing from a Single-Node Linked List

Details:
- **Description**: This test evaluates how the function behaves when there is only one node in the list. The function should delegate to `RemoveAtBeg` and return the value of the single node.
- **Execution**:
  - **Arrange**: Create a `LinkedList` with one node.
  - **Act**: Call the `RemoveAtEnd` method.
  - **Assert**: Verify that the returned value is the value of the single node.
- **Validation**:
  - **Assertion**: The return value should match the value of the single node, as the function should call `RemoveAtBeg` in this case.
  - **Importance**: This test confirms that the function properly handles the edge case where the list contains only one node, by correctly delegating responsibility to `RemoveAtBeg`.

---

### Scenario 3: Removing from a Two-Node Linked List

Details:
- **Description**: This test verifies the behavior of the `RemoveAtEnd` method when the linked list contains exactly two nodes. The function should remove the last node and return its value.
- **Execution**:
  - **Arrange**: Create a `LinkedList` with two nodes.
  - **Act**: Call the `RemoveAtEnd` method.
  - **Assert**: Verify that the return value is the value of the second node (the one being removed), and that the list now contains only the first node.
- **Validation**:
  - **Assertion**: The test expects the value of the second node to be returned and the first node to remain intact.
  - **Importance**: This test ensures that the function can correctly traverse a list with two nodes and remove the last one without affecting the first node.

---

### Scenario 4: Removing from a Multi-Node Linked List

Details:
- **Description**: This test checks the behavior of the `RemoveAtEnd` method when the linked list contains multiple nodes (more than two). The function should remove the last node and return its value, leaving the rest of the list unchanged.
- **Execution**:
  - **Arrange**: Create a `LinkedList` with several nodes (e.g., 4 or 5 nodes).
  - **Act**: Call the `RemoveAtEnd` method.
  - **Assert**: Verify that the returned value is the value of the last node, and the second-to-last node's `next` pointer is set to `nil`.
- **Validation**:
  - **Assertion**: The test expects the value of the last node to be returned, and the second-to-last node to have its `next` pointer set to `nil`.
  - **Importance**: This test ensures that the function correctly traverses longer linked lists and properly removes the last node without affecting the other nodes.

---

### Scenario 5: Ensuring `RemoveAtBeg` is Called for Single Node

Details:
- **Description**: This test ensures that the `RemoveAtEnd` method calls the `RemoveAtBeg` method when there is only one node in the list. This is important to check because the function directly delegates to `RemoveAtBeg` in this case.
- **Execution**:
  - **Arrange**: Create a `LinkedList` with one node and mock or spy on the `RemoveAtBeg` method.
  - **Act**: Call the `RemoveAtEnd` method.
  - **Assert**: Verify that the `RemoveAtBeg` method was called exactly once.
- **Validation**:
  - **Assertion**: The test expects the `RemoveAtBeg` method to be invoked once.
  - **Importance**: This test is crucial for verifying that the function follows the intended logic path for single-node lists by delegating to `RemoveAtBeg`.

---

### Scenario 6: Removing from a List After Multiple Removals

Details:
- **Description**: This test checks the behavior of the `RemoveAtEnd` method after multiple consecutive removals to ensure the list's integrity is maintained. The function should correctly remove the last node each time.
- **Execution**:
  - **Arrange**: Create a `LinkedList` with several nodes.
  - **Act**: Call the `RemoveAtEnd` method multiple times.
  - **Assert**: After each removal, verify that the returned value matches the last node's value before removal, and that the list size decreases by one.
- **Validation**:
  - **Assertion**: The test expects the correct value to be returned each time and the list size to decrease accordingly.
  - **Importance**: This test ensures that the function behaves correctly when called multiple times in succession, maintaining the integrity of the list structure after each removal.

---

### Scenario 7: Removing from a List with Duplicate Values

Details:
- **Description**: This test checks the behavior of the `RemoveAtEnd` method when the linked list contains duplicate values. The function should remove the last node irrespective of the values.
- **Execution**:
  - **Arrange**: Create a `LinkedList` with nodes having duplicate values.
  - **Act**: Call the `RemoveAtEnd` method.
  - **Assert**: Verify that the function removes the last node and returns its value, even if duplicate values are present in the list.
- **Validation**:
  - **Assertion**: The test expects the value of the last node to be returned, regardless of whether the values in the list are duplicates.
  - **Importance**: This test ensures that the function handles lists with duplicate values correctly and removes the last node based on its position, not its value.

---

### Scenario 8: Removing from a List with Mixed Data Types (if applicable)

Details:
- **Description**: This test checks the behavior of the `RemoveAtEnd` method when the linked list contains nodes with mixed data types (if the implementation allows for such flexibility). The function should remove the last node and return the correct value.
- **Execution**:
  - **Arrange**: Create a `LinkedList` with nodes containing mixed data types (e.g., integers, strings).
  - **Act**: Call the `RemoveAtEnd` method.
  - **Assert**: Verify that the function removes the last node and returns its value, regardless of the data type.
- **Validation**:
  - **Assertion**: The test expects the value of the last node to be returned, irrespective of its data type.
  - **Importance**: This test ensures that the function handles lists with mixed data types (if allowed) and correctly removes the last node without any type-related issues.

---

### Scenario 9: Removing from a Circular Linked List (if applicable)

Details:
- **Description**: This test checks the behavior of the `RemoveAtEnd` method when the linked list is circular (if the implementation allows for such structures). The function should correctly remove the last node and break the circular link.
- **Execution**:
  - **Arrange**: Create a circular `LinkedList` where the last node points back to the head.
  - **Act**: Call the `RemoveAtEnd` method.
  - **Assert**: Verify that the function removes the last node and breaks the circular link.
- **Validation**:
  - **Assertion**: The test expects the last node to be removed, and the circular link to be broken.
  - **Importance**: This test ensures that the function works correctly with circular linked lists (if applicable) and breaks the circular reference when removing the last node.

---

These scenarios cover a wide range of cases, including normal operations, edge cases, and potential error conditions. Each scenario ensures that the `RemoveAtEnd` function behaves as expected under various circumstances.
*/

// ********RoostGPT********
package LinkedList

import (
	"bytes"
	"fmt"
	"os"
	"testing"
)

type node struct {
	val  int
	next *node
}

// Simulated LinkedList type with a head pointer to the node
type LinkedList struct {
	head *node
}

// Placeholder method for RemoveAtBeg (used in the actual method)
func (ll *LinkedList) RemoveAtBeg() int {
	if ll.head == nil {
		return -1
	}
	retval := ll.head.val
	ll.head = ll.head.next
	return retval
}

func TestRemoveAtEnd(t *testing.T) {
	tests := []struct {
		name          string
		initialNodes  []int
		expectedValue int
		expectedNodes []int
	}{
		{
			name:          "Removing from an Empty LinkedList",
			initialNodes:  []int{},
			expectedValue: -1,
			expectedNodes: []int{},
		},
		{
			name:          "Removing from a Single-Node LinkedList",
			initialNodes:  []int{10},
			expectedValue: 10,
			expectedNodes: []int{},
		},
		{
			name:          "Removing from a Two-Node LinkedList",
			initialNodes:  []int{10, 20},
			expectedValue: 20,
			expectedNodes: []int{10},
		},
		{
			name:          "Removing from a Multi-Node LinkedList",
			initialNodes:  []int{10, 20, 30, 40},
			expectedValue: 40,
			expectedNodes: []int{10, 20, 30},
		},
		{
			name:          "Removing from a List with Duplicate Values",
			initialNodes:  []int{10, 20, 20, 30},
			expectedValue: 30,
			expectedNodes: []int{10, 20, 20},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ll := &LinkedList{}
			for _, val := range tt.initialNodes {
				ll.addNode(val)
			}

			// Capturing os.Stdout to verify non-returning function behavior
			var buf bytes.Buffer
			stdout := os.Stdout
			os.Stdout = &buf
			defer func() { os.Stdout = stdout }()

			// Act
			actualValue := ll.RemoveAtEnd()

			// Assert
			if actualValue != tt.expectedValue {
				t.Errorf("RemoveAtEnd() = %v, want %v", actualValue, tt.expectedValue)
			} else {
				t.Logf("Success: RemoveAtEnd() returned %v as expected.", actualValue)
			}

			// Verify the remaining nodes in the linked list
			remainingNodes := ll.getAllValues()
			if len(remainingNodes) != len(tt.expectedNodes) {
				t.Errorf("Remaining nodes = %v, want %v", remainingNodes, tt.expectedNodes)
			} else {
				for i, val := range remainingNodes {
					if val != tt.expectedNodes[i] {
						t.Errorf("Node at index %d = %v, want %v", i, val, tt.expectedNodes[i])
					}
				}
				t.Logf("Success: Remaining nodes after removal are as expected.")
			}
		})
	}
}

// Utility method to add node to the end of the list (for test setup)
func (ll *LinkedList) addNode(val int) {
	newNode := &node{val: val}
	if ll.head == nil {
		ll.head = newNode
		return
	}
	cur := ll.head
	for cur.next != nil {
		cur = cur.next
	}
	cur.next = newNode
}

// Utility method to get all values from the linked list (for validation)
func (ll *LinkedList) getAllValues() []int {
	var values []int
	for cur := ll.head; cur != nil; cur = cur.next {
		values = append(values, cur.val)
	}
	return values
}
