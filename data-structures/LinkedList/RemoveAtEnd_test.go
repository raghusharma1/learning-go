// ********RoostGPT********
/*
Test generated by RoostGPT for test goastparsertest using AI Type  and AI Model 

ROOST_METHOD_HASH=RemoveAtEnd_cbcd36b1fc
ROOST_METHOD_SIG_HASH=RemoveAtEnd_5992bd4f5a

### Scenario 1: Removing from an Empty Linked List

Details:  
**Description**: This test checks the behavior of the `RemoveAtEnd` method when the linked list is empty. The function is expected to return `-1` when called on an empty list, as there are no elements to remove.  
**Execution**:  
- **Arrange**: Create an empty linked list (i.e., the `head` of the linked list is `nil`).  
- **Act**: Call `RemoveAtEnd()` on this empty list.  
- **Assert**: Verify that the returned value is `-1`.  
**Validation**:  
- The choice of using `-1` as the return value for an empty list is logical since it represents an invalid operation (removing from an empty list).  
- This test ensures that the function handles edge cases where the list is empty, preventing potential runtime errors or crashes.

---

### Scenario 2: Removing from a Single-Element Linked List

Details:  
**Description**: This test verifies the behavior of the `RemoveAtEnd` method when the linked list contains only one element. In this case, `RemoveAtEnd()` should behave like `RemoveAtBeg()` and remove the only element in the list.  
**Execution**:  
- **Arrange**: Create a linked list with one element (e.g., `head` points to a node with a value, and `next` is `nil`).  
- **Act**: Call `RemoveAtEnd()` on this single-element list.  
- **Assert**: Verify that the returned value is the value of the single node and that the list is now empty (`head == nil`).  
**Validation**:  
- The test ensures that the function correctly handles the case where only one element exists in the list, and that it behaves as expected (delegates to `RemoveAtBeg()`).

---

### Scenario 3: Removing from a Two-Element Linked List

Details:  
**Description**: This test examines the behavior of the `RemoveAtEnd` method when the linked list contains exactly two elements. The function should remove the last element and update the list's `next` pointer of the first node to `nil`.  
**Execution**:  
- **Arrange**: Create a linked list with two elements (e.g., `head` points to a node, and the `next` of the first node points to the second node).  
- **Act**: Call `RemoveAtEnd()` on this two-element list.  
- **Assert**: Verify that the returned value is the value of the second node, and that the first node's `next` pointer is now `nil`.  
**Validation**:  
- This test ensures that the function correctly updates the internal pointers when removing the last element in a list of two elements, and that the correct value is returned.

---

### Scenario 4: Removing from a Multi-Element Linked List

Details:  
**Description**: This test verifies the behavior of the `RemoveAtEnd` method when the linked list contains more than two elements. The function should remove the last node and update the `next` pointer of the second-to-last node to `nil`.  
**Execution**:  
- **Arrange**: Create a linked list with three or more elements.  
- **Act**: Call `RemoveAtEnd()` on this multi-element list.  
- **Assert**: Verify that the returned value is the value of the last node, and that the second-to-last node's `next` pointer is now `nil`.  
**Validation**:  
- This test ensures that the function correctly handles lists with multiple elements and that the internal structure of the list is updated appropriately.

---

### Scenario 5: Multiple Consecutive Removals from a Multi-Element List

Details:  
**Description**: This test checks if the `RemoveAtEnd` method can be called multiple times consecutively on a multi-element list until the list is empty. Each call should remove the last element, and the list should eventually be empty.  
**Execution**:  
- **Arrange**: Create a linked list with three or more elements.  
- **Act**: Call `RemoveAtEnd()` multiple times until the list becomes empty.  
- **Assert**: Verify that each call returns the correct value, and after all elements are removed, the `head` of the list is `nil`.  
**Validation**:  
- This test ensures that the function can handle consecutive calls and correctly updates the list until it is empty.

---

### Scenario 6: Removing from a Null-Initialized Linked List

Details:  
**Description**: This test checks the behavior of the `RemoveAtEnd` method when the linked list is initialized but never populated (i.e., `head` is explicitly set to `nil`). The function should return `-1`, similar to an empty list.  
**Execution**:  
- **Arrange**: Create a linked list where `head` is explicitly set to `nil`.  
- **Act**: Call `RemoveAtEnd()` on this list.  
- **Assert**: Verify that the returned value is `-1`.  
**Validation**:  
- This test ensures that the function correctly handles the case where the linked list is initialized but contains no elements, ensuring robustness in initialization scenarios.

---

### Scenario 7: Removing After Adding and Removing Multiple Times

Details:  
**Description**: This test verifies if the `RemoveAtEnd` method behaves correctly after multiple additions and removals of elements. The function should still remove the correct last element after multiple operations.  
**Execution**:  
- **Arrange**: Create a linked list, add several elements, remove some elements, and then call `RemoveAtEnd()`.  
- **Act**: Call `RemoveAtEnd()` after performing multiple add and remove operations.  
- **Assert**: Verify that the correct last element is removed, and the list is updated correctly.  
**Validation**:  
- This test ensures that the function can handle complex scenarios where multiple operations are performed on the list, maintaining correct behavior and data integrity.

---

### Scenario 8: Removing from a Circular Linked List (Invalid Case)

Details:  
**Description**: This test attempts to check the behavior of the `RemoveAtEnd` method when applied to an incorrectly implemented circular linked list (i.e., where the last element points back to the first element). The function should either handle this gracefully or fail (this could be an invalid case for a singly linked list).  
**Execution**:  
- **Arrange**: Create a circular linked list where the `next` pointer of the last node points back to the first node.  
- **Act**: Call `RemoveAtEnd()` on this circular list.  
- **Assert**: Verify that the function either throws an error, returns an invalid result, or handles the case gracefully (depending on the implementation).  
**Validation**:  
- This test ensures that the function can handle (or at least not crash) when faced with an incorrectly implemented circular linked list. It tests the robustness of the function in edge cases.

---

### Scenario 9: Removing with Incorrect Node Struct (Invalid Case)

Details:  
**Description**: This test examines the behavior of the `RemoveAtEnd` method when the linked list is incorrectly structured (e.g., nodes with missing or invalid `next` pointers). The function should throw an error or fail gracefully.  
**Execution**:  
- **Arrange**: Create a linked list where some nodes have invalid or missing `next` pointers.  
- **Act**: Call `RemoveAtEnd()` on this malformed list.  
- **Assert**: Verify that the function either throws an error or returns an invalid result.  
**Validation**:  
- This test ensures that the function can handle malformed or corrupted linked lists without causing crashes or undefined behavior.

---

These test scenarios cover a wide range of cases, from normal operations to edge cases, and ensure that the `RemoveAtEnd` function behaves robustly across different situations.
*/

// ********RoostGPT********
package LinkedList

import (
	"bytes"
	"fmt"
	"os"
	"testing"
)

// Helper structs and methods
type node struct {
	val  int
	next *node
}

func (ll *LinkedList) RemoveAtBeg() int {
	if ll.head == nil {
		return -1
	}
	val := ll.head.val
	ll.head = ll.head.next
	return val
}

// TestRemoveAtEnd - Table driven test for RemoveAtEnd method
func TestRemoveAtEnd(t *testing.T) {
	tests := []struct {
		name        string
		setup       func() *LinkedList
		expectedVal int
		expectedLog string
	}{
		{
			name: "Removing from an Empty Linked List",
			setup: func() *LinkedList {
				return &LinkedList{head: nil}
			},
			expectedVal: -1,
			expectedLog: "Attempted to remove from an empty list",
		},
		{
			name: "Removing from a Single-Element Linked List",
			setup: func() *LinkedList {
				return &LinkedList{head: &node{val: 10, next: nil}}
			},
			expectedVal: 10,
			expectedLog: "Removed the only element from the list",
		},
		{
			name: "Removing from a Two-Element Linked List",
			setup: func() *LinkedList {
				n2 := &node{val: 20, next: nil}
				n1 := &node{val: 10, next: n2}
				return &LinkedList{head: n1}
			},
			expectedVal: 20,
			expectedLog: "Removed from a two-element list, first element next is now nil",
		},
		{
			name: "Removing from a Multi-Element Linked List",
			setup: func() *LinkedList {
				n3 := &node{val: 30, next: nil}
				n2 := &node{val: 20, next: n3}
				n1 := &node{val: 10, next: n2}
				return &LinkedList{head: n1}
			},
			expectedVal: 30,
			expectedLog: "Removed from a multi-element list, second-to-last element's next is now nil",
		},
		{
			name: "Multiple Consecutive Removals from a Multi-Element List",
			setup: func() *LinkedList {
				n3 := &node{val: 30, next: nil}
				n2 := &node{val: 20, next: n3}
				n1 := &node{val: 10, next: n2}
				return &LinkedList{head: n1}
			},
			expectedVal: 10, // Final call will remove the last element
			expectedLog: "Multiple consecutive removals, list is now empty",
		},
		{
			name: "Removing from a Null-Initialized Linked List",
			setup: func() *LinkedList {
				return &LinkedList{head: nil}
			},
			expectedVal: -1,
			expectedLog: "Attempted to remove from a null-initialized list",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Arrange
			ll := tt.setup()

			// Capture output
			var buf bytes.Buffer
			fmt.Fprintf(&buf, "Before removal, head: %v\n", ll.head)

			// Act
			val := ll.RemoveAtEnd()

			// Assert
			if val != tt.expectedVal {
				t.Errorf("expected %d, got %d", tt.expectedVal, val)
			}

			// Log output
			if val == tt.expectedVal {
				fmt.Fprintf(&buf, "Success: %s\n", tt.expectedLog)
			} else {
				fmt.Fprintf(&buf, "Failure: expected %d but got %d\n", tt.expectedVal, val)
			}

			// Print captured output
			fmt.Fprintf(os.Stdout, buf.String())
		})
	}
}
